<body style="background:white"></body>
<script src="https://unpkg.com/tone"></script>
<script src="https://cdn.jsdelivr.net/gh/netizenorg/netnet-standard-library/build/nn.min.js"></script>
<script>
  /* global Tone, nn */
  //loading images & dimensions
  // const pinkFlower = 'PinkFlower.png'
  // const orangeFlower = 'TransparentOrangeFlower.png'
  // const redFlower = 'flower-4ms.png'
  // const blueFlower = 'SmallBlueFlower.png'
  // const greenFlower = 'GreenFlower.png'
  
  //determening the scale
 
  // const flowers = [pinkFlower, orangeFlower, redFlower, blueFlower, greenFlower]
  const hueMax = 360
  const otherMax = 100
  const chordsList = Object.keys(nn.chords)
  const chordLen = Object.keys(nn.chords).length
  const modeNames = Object.keys(nn.mode)
  const modeLen = Object.keys(nn.mode).length
  
  const screenWidth = nn.width
  const screenLength = nn.length
  //take in user image
  const btn = nn.create('button')
    .content('upload image')
    .set('id', 'upload')
    .addTo('body')
  //first sort the modes by 'brightness'
  function brightness(intervals) {
  let bright = 0;
  for (let i = 1; i < intervals.length; i++) {
    const step = intervals[i] - intervals[i - 1];
    if (step >= 2) bright += step;
  }
  return bright;
}

  const sorted = Object.entries(nn.modes)
    .map(([name, arr]) => ({ name, arr, bright: brightness(arr) }))
    .sort((a, b) => a.bright - b.bright);  
  
  //strictly image (png, jpg) files, run through helper HSV func
  const uploader = new nn.FileUploader({
    click: '#upload',
    ready: async (file) => {
      const hsv = await dominantHSVFromBase64(file.data)
      const arr = nn.notes
      //const idx = Math.floor((hsv.h / 360) * arr.length) % arr.length
      //setup values to create inst and play sound
      //hue = mode
      const hueToMode = otherMax/ModeLen //2.32
      let modeIdx = math.floor(hsv.h/hueToMode)
      let mode = sorted[modeIdx]
      
      //saturation = key
      let key
      
      //value = chord
      let chord
      
      //create scale
      
      let scale = []
      //
      //pass hsv info to create instrument
      
      //length of instrument
      let len = mode + key
      setupInstrument(len)
      
      setupInstrument(hsv.h, hsv.s, hsv.v)
      //playChord(idx)
    },
    error: (err) => {
      console.error(err)
    }
  })
  
  //
  async function dominantHSVFromBase64(dataURL, { bins = 36, satFloor = 20 } = {}) {
    const hist = new Array(bins).fill(0)
    const satSum = new Array(bins).fill(0)
    const valSum = new Array(bins).fill(0)

    await nn.modifyPixels(dataURL, pixels => {
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2], a = pixels[i + 3]
        if (a === 0) continue

        const { h, s, v } = nn.rgb2hsv(r, g, b) // s, v in 0â€“100
        if (s <= satFloor) continue

        const bin = Math.floor(h / (360 / bins)) % bins
        const weight = (s / 100) * (v / 100)

        hist[bin] += weight
        satSum[bin] += s * weight
        valSum[bin] += v * weight
      }
    })

    const total = hist.reduce((a, b) => a + b, 0)
    if (total === 0) return null

    // find the dominant hue bin
    let best = 0, bestIdx = 0
    for (let i = 0; i < bins; i++) if (hist[i] > best) { best = hist[i]; bestIdx = i }

    const hue = ((bestIdx + 0.5) * (360 / bins)) % 360
    const sat = satSum[bestIdx] / hist[bestIdx]  // weighted average
    const val = valSum[bestIdx] / hist[bestIdx]  // weighted average

    return { h: hue, s: sat, v: val }
  }

  //select your scale:
  
  // const scaleText = nn.create('div')
  //   .content('Your image has a scale of: ')
  //   .addTo('body')
  
//   for (let i = 0; i < len(flowers); i++) {

//   }
  //set up synth
  
  function setupInstrument(length, h, s, v) {
    const synth = new Tone.Synth().toDestination()
    //const tuningSystem = 12
    
    for (let i = 0; i < length; i++) {
      const keyUI = nn.create('div')
      .css({
        opacity: 0.3,
        width: 100,
        height: 300,
        backgroundSize: 'cover',
        clipPath:'circle(60% at 60% 60%)'
      })
        .position(191 + (i*100), 191)
        .addTo('body')
        .on('mouseenter', () => playSound(keyUI, h, s, v))
        .on('mouseleave', 
          () => {keyUI.css({background: 'black', 
                          backgroundSize: 'cover'})})
    }
    
  }

  
  //set up function to play sound and select random colors 
  function playSound(circle, h, s, v) {
    //select scale
    // use value to find mode (brightness) by dividing into 100% into 43 pieces
    const hueToMode = otherMax/ModeLen //2.32
    let modeIdx = Math.floor(h/hueToMode) //find idx btwn 0-42 * need to fix
    let mode = sorted[modeIdx]
    
    //hue correpsons to the key (A, B, C)
    let key = 
    
    //v corresponds to the chord
    let chord 
    
    //create the scale
    scale = [
      ..nn.createScale(, mode)
    ]
    
    //they'll need to be declared outside bc need to create insturment
    
    
    //create the instrument
    synth.triggerAttackRelease(200 * (i+1), '8n')
    circle.css('background', nn.randomColor())
  }
</script>