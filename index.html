<body style="background:white"></body>
<script src="https://unpkg.com/tone"></script>
<script src="https://cdn.jsdelivr.net/gh/netizenorg/netnet-standard-library/build/nn.min.js"></script>
<script>
  /* global Tone, nn */
  //loading images & dimensions
  // const pinkFlower = 'PinkFlower.png'
  // const orangeFlower = 'TransparentOrangeFlower.png'
  // const redFlower = 'flower-4ms.png'
  // const blueFlower = 'SmallBlueFlower.png'
  // const greenFlower = 'GreenFlower.png'
  
  //determening the scale
 
  // const flowers = [pinkFlower, orangeFlower, redFlower, blueFlower, greenFlower]
  const hueMax = 360
  const satMax = 100
  const valMax = 100
  
  const notesList = Object.keys(nn.notes)
  const notesLen = notesList.length
  
  const modeNames = Object.keys(nn.mode)
  const modeLen = modeNames.length
  
  const chordsList = Object.keys(nn.chords)
  const chordLen = chordsList.length
  
  const screenWidth = nn.width
  const screenLength = nn.length
  //take in user image
  const btn = nn.create('button')
    .content('upload image')
    .set('id', 'upload')
    .addTo('body')
  //first sort the modes by 'brightness'
  function brightness(intervals) {
  let bright = 0;
  for (let i = 1; i < intervals.length; i++) {
    const step = intervals[i] - intervals[i - 1];
    if (step >= 2) bright += step;
  }
  return bright;
}

  const sortedModeNames = Object.entries(nn.modes)
    .map(([name, arr]) => ({ name, arr, bright: brightness(arr) }))
    .sort((a, b) => a.bright - b.bright);  
  
  //strictly image (png, jpg) files, run through helper HSV func
  const uploader = new nn.FileUploader({
    click: '#upload',
    ready: async (file) => {
      const hsv = await dominantHSVFromBase64(file.data)
      //const arr = nn.notes
      //const idx = Math.floor((hsv.h / 360) * arr.length) % arr.length
      //setup values to create inst and play sound
      
      //hue = note/key, C, D, E etc. selecting the 'color'
      //given value 0-360, scale to a note/key options (128)
      const scaledKeyFromHueIdx = Math.round((hsv.h/hueMax) * notesLen)
      const key = notesList[scaledKeyFromHueIdx]
      
      //saturation = mode,how much of the color is there/do we want (max 100%), (can switch w value depending on how it sounds)
      //given value 0-100%, scale to mode options (modeLen)
      const scaledModeFromSatIdx = Math.round((hsv.s/satMax) * modeLen)
      const mode = sortedModeNames[scaledModeFromSatIdx]
      
      //value = chord, brightness of the color (max 100%)
      const scaledChordFromValIdx = Math.round((hsv.v/valMax) * chordLen)
      const chordShape = chordsList[scaledChordFromValIdx]
      
      //create scale
      //test +3, +4
      let scale = [
        ...nn.createScale(key + 3, mode),
        ...nn.createScale(key + 4, mode)
      ]
      
      const chord = nn.createChord(scale, chordShape)
      
      let len = chord.length
      
      setupInstrument(len, scale, chord)
      
      
      //
      //pass hsv info to create instrument
      
      //length of instrument
      
      setupInstrument(len)
      
      setupInstrument(hsv.h, hsv.s, hsv.v)
      //playChord(idx)
    },
    error: (err) => {
      console.error(err)
    }
  })
  
  //
  async function dominantHSVFromBase64(dataURL, { bins = 36, satFloor = 20 } = {}) {
    const hist = new Array(bins).fill(0)
    const satSum = new Array(bins).fill(0)
    const valSum = new Array(bins).fill(0)

    await nn.modifyPixels(dataURL, pixels => {
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2], a = pixels[i + 3]
        if (a === 0) continue

        const { h, s, v } = nn.rgb2hsv(r, g, b) // s, v in 0â€“100
        if (s <= satFloor) continue

        const bin = Math.floor(h / (360 / bins)) % bins
        const weight = (s / 100) * (v / 100)

        hist[bin] += weight
        satSum[bin] += s * weight
        valSum[bin] += v * weight
      }
    })

    const total = hist.reduce((a, b) => a + b, 0)
    if (total === 0) return null

    // find the dominant hue bin
    let best = 0, bestIdx = 0
    for (let i = 0; i < bins; i++) if (hist[i] > best) { best = hist[i]; bestIdx = i }

    const hue = ((bestIdx + 0.5) * (360 / bins)) % 360
    const sat = satSum[bestIdx] / hist[bestIdx]  // weighted average
    const val = valSum[bestIdx] / hist[bestIdx]  // weighted average

    return { h: hue, s: sat, v: val }
  }

  //select your scale:
  
  // const scaleText = nn.create('div')
  //   .content('Your image has a scale of: ')
  //   .addTo('body')
  
//   for (let i = 0; i < len(flowers); i++) {

//   }
  //set up synth
  
  //create playable instrument and notes
  function setupInstrument(length, scale, chord) {
    const synth = new Tone.Synth().toDestination()
    //const tuningSystem = 12
    
    for (let i = 0; i < length; i++) {
      const keyUI = nn.create('div')
      .css({
        opacity: 0.3,
        width: 100,
        height: 300,
        backgroundSize: 'cover',
        clipPath:'circle(60% at 60% 60%)'
      })
        .position(191 + (i*100), 191)
        .addTo('body')
        .on('mouseenter', () => playSound(keyUI, scale, chord, i, length))
        .on('mouseleave', 
          () => {keyUI.css({background: 'black', 
                          backgroundSize: 'cover'})})
    }
    
  }

  
  //set up function to play sound and select random colors 
  function playSound(circle, scale, chord, i, length) {
    
    //they'll need to be declared outside bc need to create insturment
    
    const note = chord[i % length]
    //create the instrument
    synth.triggerAttackRelease(note, '8n')
    circle.css('background', nn.randomColor())
  }
</script>