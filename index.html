<body style="background:white"></body>
<script src="https://unpkg.com/tone"></script>
<script src="https://algorithmicmusic.online/js/libs/nn.min.js"></script>
<script>
  /* global Tone, nn */
  //loading images & dimensions
  // const pinkFlower = 'PinkFlower.png'
  // const orangeFlower = 'TransparentOrangeFlower.png'
  // const redFlower = 'flower-4ms.png'
  // const blueFlower = 'SmallBlueFlower.png'
  // const greenFlower = 'GreenFlower.png'
  
  //determening the scale
 
  // const flowers = [pinkFlower, orangeFlower, redFlower, blueFlower, greenFlower]
  //brightness doesnt quite work. I think its the way brightenss' is decided/sorted and how brightness is picked based on the hue
  const hueMax = 360
  const satMax = 100
  const valMax = 100
  
  const notesList = nn.notes
  const notesLen = notesList.length
  
  const modeNames = Object.keys(nn.modes)
  const modeLen = modeNames.length
  
  const chordsList = Object.keys(nn.chords)
  const chordLen = chordsList.length
  
  const screenWidth = nn.width
  const screenLength = nn.length
  
  let divsPresent = false
  
  let scale
  //take in user image
  const btn = nn.create('button')
    .content('upload image')
    .set('id', 'upload')
    .addTo('body')
    .position(screenWidth/2 - 50, 50)
  if (divsPresent) {
    btn.on('mousedown', deleteDiv())
  }

  //first sort the modes by 'brightness'
  function brightness(intervals) {
  let bright = 0;
  for (let i = 1; i < intervals.length; i++) {
    const step = intervals[i] - intervals[i - 1];
    if (step >= 2) bright += step;
  }
  return bright;
}

  const sortedModeNames = Object.entries(nn.modes)
    .map(([name, arr]) => ({ name, arr, bright: brightness(arr) }))
    .sort((a, b) => a.bright - b.bright);  
  console.log(sortedModeNames)
  
  //strictly image (png, jpg) files, run through helper HSV func
  const uploader = new nn.FileUploader({
    click: '#upload',
    ready: async (file) => {
      const hsv = await dominantHSVFromBase64(file.data)

      //setup values to create inst and play sound
      
      //hue = note/key, C, D, E etc. selecting the 'color'
      //given value 0-360, scale to a note/key options (128)
      const scaledKeyFromHueIdx = Math.round((hsv.h/hueMax) * notesLen) % notesLen
      const key = notesList[scaledKeyFromHueIdx]
      console.log(notesList)
      
      //saturation = mode,how much of the color is there/do we want (max 100%), (can switch w value depending on how it sounds)
      //given value 0-100%, scale to mode options (modeLen)
      const scaledModeFromSatIdx = Math.round((hsv.s/satMax) * modeLen + 500) % modeLen
      const modeArrLen = sortedModeNames[scaledModeFromSatIdx].arr.length
      const mode = sortedModeNames[scaledModeFromSatIdx].name
      
      //value = chord, brightness of the color (max 100%)
      const scaledChordFromValIdx = Math.round((hsv.v/valMax) * chordLen) % chordLen
      const chordShape = chordsList[scaledChordFromValIdx]
      
      //create scale
      //test +3, +4
      scale = [
        ...nn.createScale(key + 3, mode),
        ...nn.createScale(key + 4, mode)
      ]
      console.log('scale is ' + scale)
      console.log(chordShape)
      const chord = nn.createChord(scale, chordShape)
      
      //console.log(chord.value)
      //need to set length as length of chord that will played, not mode bc not all notes in mode will be played if we select a specific chord
      console.log(modeArrLen)
      let len = modeArrLen
      
      setupInstrument(len, scale, chord)

    },
    error: (err) => {
      console.error(err)
    }
  })
  
  //
  async function dominantHSVFromBase64(dataURL, { bins = 36, satFloor = 20 } = {}) {
    const hist = new Array(bins).fill(0)
    const satSum = new Array(bins).fill(0)
    const valSum = new Array(bins).fill(0)

    await nn.modifyPixels(dataURL, pixels => {
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2], a = pixels[i + 3]
        if (a === 0) continue

        const { h, s, v } = nn.rgb2hsv(r, g, b) // s, v in 0â€“100
        if (s <= satFloor) continue

        const bin = Math.floor(h / (360 / bins)) % bins
        const weight = (s / 100) * (v / 100)

        hist[bin] += weight
        satSum[bin] += s * weight
        valSum[bin] += v * weight
      }
    })

    const total = hist.reduce((a, b) => a + b, 0)
    if (total === 0) return null

    // find the dominant hue bin
    let best = 0, bestIdx = 0
    for (let i = 0; i < bins; i++) if (hist[i] > best) { best = hist[i]; bestIdx = i }

    const hue = ((bestIdx + 0.5) * (360 / bins)) % 360
    const sat = satSum[bestIdx] / hist[bestIdx]  // weighted average
    const val = valSum[bestIdx] / hist[bestIdx]  // weighted average

    return { h: hue, s: sat, v: val }
  }

  //select your scale:
  
  // const scaleText = nn.create('div')
  //   .content('Your image has a scale of: ')
  //   .addTo('body')
  
//   for (let i = 0; i < len(flowers); i++) {

//   }
  //set up synth
  
  //create playable instrument and notes
  const synth = new Tone.Synth().toDestination()
  function setupInstrument(length, scale, chord) {
    divsPresent = true
    //const synth = new Tone.Synth().toDestination()
    //const tuningSystem = 12
    console.log(length)
    for (let i = 0; i < length; i++) {
      const keyUI = nn.create('div')
      .css({
        opacity: 0.8,
        width: 50,
        height: 300 + (50 * (i % 2)),
        backgroundSize: 'cover',
        clipPath:'circle(60% at 50% 50%)'
      })
        .position(((screenWidth/2) - 175) + (i*100), 100) 
        .addTo('body')
        .on('mouseenter', () => playSound(keyUI, scale, chord, i, length))
        .on('mouseleave', 
          () => {keyUI.css({background: 'black', 
                          backgroundSize: 'cover'})})
    }
    
  }

  
  //set up function to play sound and select random colors 
  function playSound(keyUI, scale, chord, i, length) {
    
    //they'll need to be declared outside bc need to create insturment
    
    const note = chord[i % length]
    //create the instrument
    synth.triggerAttackRelease(note, 1)
    keyUI.css('background', nn.randomColor())
  }
  function deleteDiv() {
    if (divsPresent) {
      keyUI.remove()
    }
  }
  
</script>